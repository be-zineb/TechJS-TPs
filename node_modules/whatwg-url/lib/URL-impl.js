"use strict";
const usm = require("./url-state-machine");
<<<<<<< HEAD
const urlencoded = require("./urlencoded");
const URLSearchParams = require("./URLSearchParams");

exports.implementation = class URLImpl {
  // Unlike the spec, we duplicate some code between the constructor and canParse, because we want to give useful error
  // messages in the constructor that distinguish between the different causes of failure.
  constructor(globalObject, [url, base]) {
    let parsedBase = null;
    if (base !== undefined) {
      parsedBase = usm.basicURLParse(base);
      if (parsedBase === null) {
        throw new TypeError(`Invalid base URL: ${base}`);
=======

exports.implementation = class URLImpl {
  constructor(constructorArgs) {
    const url = constructorArgs[0];
    const base = constructorArgs[1];

    let parsedBase = null;
    if (base !== undefined) {
      parsedBase = usm.basicURLParse(base);
      if (parsedBase === "failure") {
        throw new TypeError("Invalid base URL");
>>>>>>> 44d107a8e7e31b29aafd31d6af9d37e2211951cd
      }
    }

    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
<<<<<<< HEAD
    if (parsedURL === null) {
      throw new TypeError(`Invalid URL: ${url}`);
    }

    const query = parsedURL.query !== null ? parsedURL.query : "";

    this._url = parsedURL;

    // We cannot invoke the "new URLSearchParams object" algorithm without going through the constructor, which strips
    // question mark by default. Therefore the doNotStripQMark hack is used.
    this._query = URLSearchParams.createImpl(globalObject, [query], { doNotStripQMark: true });
    this._query._url = this;
  }

  static parse(globalObject, input, base) {
    try {
      return new URLImpl(globalObject, [input, base]);
    } catch {
      return null;
    }
  }

  static canParse(url, base) {
    let parsedBase = null;
    if (base !== undefined) {
      parsedBase = usm.basicURLParse(base);
      if (parsedBase === null) {
        return false;
      }
    }

    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
    if (parsedURL === null) {
      return false;
    }

    return true;
=======
    if (parsedURL === "failure") {
      throw new TypeError("Invalid URL");
    }

    this._url = parsedURL;

    // TODO: query stuff
>>>>>>> 44d107a8e7e31b29aafd31d6af9d37e2211951cd
  }

  get href() {
    return usm.serializeURL(this._url);
  }

  set href(v) {
    const parsedURL = usm.basicURLParse(v);
<<<<<<< HEAD
    if (parsedURL === null) {
      throw new TypeError(`Invalid URL: ${v}`);
    }

    this._url = parsedURL;

    this._query._list.splice(0);
    const { query } = parsedURL;
    if (query !== null) {
      this._query._list = urlencoded.parseUrlencodedString(query);
    }
=======
    if (parsedURL === "failure") {
      throw new TypeError("Invalid URL");
    }

    this._url = parsedURL;
>>>>>>> 44d107a8e7e31b29aafd31d6af9d37e2211951cd
  }

  get origin() {
    return usm.serializeURLOrigin(this._url);
  }

  get protocol() {
<<<<<<< HEAD
    return `${this._url.scheme}:`;
  }

  set protocol(v) {
    usm.basicURLParse(`${v}:`, { url: this._url, stateOverride: "scheme start" });
=======
    return this._url.scheme + ":";
  }

  set protocol(v) {
    usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
>>>>>>> 44d107a8e7e31b29aafd31d6af9d37e2211951cd
  }

  get username() {
    return this._url.username;
  }

  set username(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    usm.setTheUsername(this._url, v);
  }

  get password() {
    return this._url.password;
  }

  set password(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    usm.setThePassword(this._url, v);
  }

  get host() {
    const url = this._url;

    if (url.host === null) {
      return "";
    }

    if (url.port === null) {
      return usm.serializeHost(url.host);
    }

<<<<<<< HEAD
    return `${usm.serializeHost(url.host)}:${usm.serializeInteger(url.port)}`;
  }

  set host(v) {
    if (usm.hasAnOpaquePath(this._url)) {
=======
    return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
  }

  set host(v) {
    if (this._url.cannotBeABaseURL) {
>>>>>>> 44d107a8e7e31b29aafd31d6af9d37e2211951cd
      return;
    }

    usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
  }

  get hostname() {
    if (this._url.host === null) {
      return "";
    }

    return usm.serializeHost(this._url.host);
  }

  set hostname(v) {
<<<<<<< HEAD
    if (usm.hasAnOpaquePath(this._url)) {
=======
    if (this._url.cannotBeABaseURL) {
>>>>>>> 44d107a8e7e31b29aafd31d6af9d37e2211951cd
      return;
    }

    usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
  }

  get port() {
    if (this._url.port === null) {
      return "";
    }

    return usm.serializeInteger(this._url.port);
  }

  set port(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    if (v === "") {
      this._url.port = null;
    } else {
      usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
    }
  }

  get pathname() {
<<<<<<< HEAD
    return usm.serializePath(this._url);
  }

  set pathname(v) {
    if (usm.hasAnOpaquePath(this._url)) {
=======
    if (this._url.cannotBeABaseURL) {
      return this._url.path[0];
    }

    if (this._url.path.length === 0) {
      return "";
    }

    return "/" + this._url.path.join("/");
  }

  set pathname(v) {
    if (this._url.cannotBeABaseURL) {
>>>>>>> 44d107a8e7e31b29aafd31d6af9d37e2211951cd
      return;
    }

    this._url.path = [];
    usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
  }

  get search() {
    if (this._url.query === null || this._url.query === "") {
      return "";
    }

<<<<<<< HEAD
    return `?${this._url.query}`;
  }

  set search(v) {
=======
    return "?" + this._url.query;
  }

  set search(v) {
    // TODO: query stuff

>>>>>>> 44d107a8e7e31b29aafd31d6af9d37e2211951cd
    const url = this._url;

    if (v === "") {
      url.query = null;
<<<<<<< HEAD
      this._query._list = [];
=======
>>>>>>> 44d107a8e7e31b29aafd31d6af9d37e2211951cd
      return;
    }

    const input = v[0] === "?" ? v.substring(1) : v;
    url.query = "";
    usm.basicURLParse(input, { url, stateOverride: "query" });
<<<<<<< HEAD
    this._query._list = urlencoded.parseUrlencodedString(input);
  }

  get searchParams() {
    return this._query;
=======
>>>>>>> 44d107a8e7e31b29aafd31d6af9d37e2211951cd
  }

  get hash() {
    if (this._url.fragment === null || this._url.fragment === "") {
      return "";
    }

<<<<<<< HEAD
    return `#${this._url.fragment}`;
=======
    return "#" + this._url.fragment;
>>>>>>> 44d107a8e7e31b29aafd31d6af9d37e2211951cd
  }

  set hash(v) {
    if (v === "") {
      this._url.fragment = null;
      return;
    }

    const input = v[0] === "#" ? v.substring(1) : v;
    this._url.fragment = "";
    usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
  }

  toJSON() {
    return this.href;
  }
};
